zmodload zsh/zprof

# Customize to your needs...
export PATH=$HOME/bin:$PATH

if [[ -f "$HOME/homebrew/bin/brew" ]]; then
    eval "$(/Users/ftakai/homebrew/bin/brew shellenv)"
    fpath=("$HOME/homebrew/share/zsh/site-functions" $fpath)
    export PATH="/Users/ftakai/homebrew/opt/coreutils/libexec/gnubin:$PATH"
fi

# My exports
if [[ -s "${ZDOTDIR:-$HOME}/.zprezto/init.zsh" ]]; then
  source "${ZDOTDIR:-$HOME}/.zprezto/init.zsh"
fi

if [[ -s /mnt/c/WINDOWS ]]; then
    export PATH="/home/ftakai/.pyenv/shims:/home/ftakai/bin:/usr/local/bin:/usr/local/sbin:/home/ftakai/.pyenv/shims:/home/ftakai/.pyenv/bin:/home/ftakai/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/usr/lib/wsl/lib"
    export NODE_OPTIONS=--openssl-legacy-provider
fi

if [[ -s "$HOME/.config/forgit/forgit.plugin.zsh" ]]; then
    source "$HOME/.config/forgit/forgit.plugin.zsh"
fi

if [[ (( $+commands[go] )) ]]; then
    export PATH="$(go env GOPATH)/bin:$PATH"
fi

alias vim=nvim

export SVN_EDITOR='vim'
export EDITOR='nvim'
export SUDO_EDITOR='nvim'

export LC_CTYPE=en_US.UTF-8
export LC_ALL=en_US.UTF-8

export GIT_EDITOR="nvim"

export HISTSIZE=1000000
export SAVEHIST=1000000
export HISTFILE="$HOME/.zsh_history"

if [[ -s "/usr/bin/virtualenvwrapper.sh" ]]; then
    source /usr/bin/virtualenvwrapper.sh
    export WORKON_HOME="$HOME/Projects/virtualenvs"
fi

alias z='j'
alias history="fc -l 1"

# export PYENV_ROOT="$HOME/.pyenv"
# export ANDROID_HOME="$HOME/Android/Sdk"

__git_files(){ 
    _wanted files expl 'local files' _files 
}

alias show_size="du --max-depth=1 -h | sort -h"

bindkey "^[[3~" delete-char
export LESS="-R"

if [[ -s "$HOME/.zsh-histdb/sqlite-history.zsh" ]]; then
    # HISTDB_TABULATE_CMD=(sed -e $'s/\x1f/\t/g')
    source $HOME/.zsh-histdb/sqlite-history.zsh
    autoload -Uz add-zsh-hook
fi

KUBECTL=$(which kubectl)

# alias kubectl='echo use kprod or any other alias, you dumbass!'
# alias kprod='kubectl'
# alias kstaging='kubectl -n staging-web'
# alias klocal='minikube kubectl --'

function kubebash(){
    instance=$(kubectl get pods | awk '{print $1}' | fzf)

    if [[ -n $instance ]]; then
        kubectl exec $instance -ti bash
    fi
}

function kubedescribe(){
    instance=$(kubectl get pods | awk '{print $1}' | fzf)

    if [[ -n $instance ]]; then
        kprod describe pod $instance | less
    fi
}


function kubelogs(){
    instance=$(kubectl get pods | awk '{print $1}' | fzf)

    if [[ -n $instance ]]; then
        kubectl logs --tail=100 -f $instance
    fi
}

function ff(){
    file=$(ag . --nocolor -l -g '' --ignore vendor --ignore dist | fzf-tmux -m -d "70%" --query="$1" --preview="bat --color=always {}" --ansi --preview-window='right:60%' +1)

    if [[ -n $file ]]; then
        print -s "nvim $(echo $file | tr '\n' ' ')"
        nvim $(echo $file | tr '\n' ' ')
    fi
}

function ffg(){
    file=$(INITIAL_QUERY="$1"
    RG_PREFIX="rg --column --line-number --no-heading --color=always --smart-case --ignore-file .gitignore"
    FZF_DEFAULT_COMMAND="$RG_PREFIX '$INITIAL_QUERY'" \
      fzf --bind "change:reload:$RG_PREFIX {q} || true" \
          --ansi --disabled --query "$INITIAL_QUERY" \
          --height=50% --layout=reverse)

    if [[ ! -z $file ]]; then
        split=("${(@s/:/)file}")
        vim $split[1] "+$split[2] norm! zzV"
    fi

}

function getpass(){
    id=$(lpass ls | sort | fzf | sed -r 's/^.*id: ([0-9]+).*$/\1/' | tr -d '\n')

    if [[ -n $id ]]; then
        pass=$(lpass show $id | grep Password | cut -d ':' -f 2 | tr -d ' ' | tr -d '\n') 
        if [[ $1 == '-n' ]]; then
            echo $pass
        else 
            echo -n $pass | copy-stuff
            echo "copied password"
        fi
    fi
}

function git-add(){ 
    forgit::add
    git commit -v
}

function git-remove(){
    forgit::reset::head
}

function git-checkout(){
    forgit::checkout::file
}

function git-branch(){
    forgit::checkout::branch
}

function gbranch(){
    git rev-parse --abbrev-ref HEAD | copy-stuff
}

alias cal="cal -3"
alias gcv="git commit -v"
alias ssh="TERM=screen-256color ssh"

function update_package(){ 
    cd ~/builds && rm -fr $1 && cower -d $1 && cd $1 && makepkg -s && notify-send -u critical "aur update" "starting to install $1" && pacI *.xz && cd -
}

function update-all-packages(){
    packages=($(cat output.txt | sed -r 's/:: ([a-z0-9-]{1,}) .*?$/\1/g' | fzf -m))
    
    if [[ -n $packages ]]; then
        for pkg in $packages; do
            echo $pkg
            echo update_package $pkg
        done
    fi
}

stty -ixon

function nvm() {
    export NVM_DIR="/home/ftakai/.nvm"
    [ -s "$NVM_DIR/nvm.sh" ] && . "$NVM_DIR/nvm.sh"  # This loads nvm
}

# The next line updates PATH for the Google Cloud SDK.
[[ -s "$HOME/builds/google-cloud-sdk/path.zsh.inc" ]] && source "$HOME/builds/google-cloud-sdk/path.zsh.inc"

# The next line enables shell command completion for gcloud.
[[ -s "$HOME/builds/google-cloud-sdk/completion.zsh.inc" ]] && source "$HOME/builds/google-cloud-sdk/completion.zsh.inc"

[[ -s "$HOME/bin/kubectl_completion" ]] && source "$HOME/bin/kubectl_completion"

[ -f ~/.fzf.zsh ] && source ~/.fzf.zsh

[ -f /usr/share/fzf/key-bindings.zsh ] && source /usr/share/fzf/key-bindings.zsh
[ -f /usr/share/fzf/completion.zsh ] && source /usr/share/fzf/completion.zsh

# source /home/ftakai/.config/broot/launcher/bash/br
export VIRTUAL_ENV_DISABLE_PROMPT=1
# complete -C '/usr/bin/aws_completer' aws

if [[ ! -f $(which pyenv) ]]; then
    export PATH="$HOME/.pyenv/bin:$PATH"
fi;

eval "$(pyenv init - --no-rehash zsh)"
export PATH="$HOME/.pyenv/shims:${PATH}"
export PYTHON_CONFIGURE_OPTS="--enable-shared"

export AWS_CONFIG_FILE="/home/ftakai/Projects/hubs/devops/config/aws-vault.cfg"
export KUBECONFIG="/home/ftakai/tmp/bootstrap-config/kubeconfig.yaml"

pgrep -f "powerline-daemon -q" 2>&1 > /dev/null || powerline-daemon -q
